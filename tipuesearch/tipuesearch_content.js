var tipuesearch = {"pages":[{"title":" ForPCA ","text":"ForPCA ForPCA : A Fortran library for principal component analysis (PCA). Usage use forpca , only : tpca type ( tpca ) :: p call p % pca ( matrix , npc , method , coeff , score , latent , explained , matrix_app ) call p % finalize () ! finalize fpm dependency If you want to use ForPCA as a dependency in your own fpm project,\nyou can easily include it by adding the following line to your fpm.toml file: [dependencies] forpca = { git = \"https://github.com/gha3mi/forpca.git\" } How to run tests Reuirements: Fortran Compiler, LAPACK or MKL Libraries Clone the repository: You can clone the ForPCA repository from GitHub using the following command: git clone https://github.com/gha3mi/forpca.git cd forpca Intel Fortran Compiler (ifort) fpm @ifort-test fpm @ifort-test-coarray Intel Fortran Compiler (ifx) fpm @ifx-test fpm @ifx-test-coarray GNU Fortran Compiler (gfortran) fpm @gfortran-test NVIDIA Compiler (nvfortran) fpm @nvfortran-test API documentation The most up-to-date API documentation for the master branch is available here .\nTo generate the API documentation for ForPCA using ford run the following\ncommand: ford ford.yml Contributing Contributions to ForPCA are welcome!\nIf you find any issues or would like to suggest improvements, please open an issue. Developer Info Seyed Ali Ghasemi","tags":"home","loc":"index.html"},{"title":"tpca – ForPCA ","text":"type, public :: tpca Components Type Visibility Attributes Name Initial integer, public :: ncol integer, public :: nrow integer, public :: npc character(len=:), public, allocatable :: method real(kind=rk), public, dimension(:,:), allocatable :: matrix real(kind=rk), public, dimension(:,:), allocatable :: coeff real(kind=rk), public, dimension(:,:), allocatable :: score real(kind=rk), public, dimension(:,:), allocatable :: matrix_app real(kind=rk), public, dimension(:,:), allocatable :: mean_data real(kind=rk), public, dimension(:), allocatable :: latent real(kind=rk), public, dimension(:), allocatable :: explained_variance Type-Bound Procedures procedure, public :: initialize private pure subroutine initialize (this, matrix, npc, method) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( tpca ), intent(inout) :: this real(kind=rk), intent(in), dimension(:,:) :: matrix integer, intent(in), optional :: npc character(len=*), intent(in), optional :: method procedure, public :: compute_coeff private impure subroutine compute_coeff (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( tpca ), intent(inout) :: this procedure, public :: compute_score private pure subroutine compute_score (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( tpca ), intent(inout) :: this procedure, public :: reconstruct_data private impure subroutine reconstruct_data (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( tpca ), intent(inout) :: this procedure, public :: cmp_explained_variance private pure subroutine cmp_explained_variance (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( tpca ), intent(inout) :: this procedure, public :: pca private impure subroutine pca (this, matrix, npc, method, coeff, score, latent, explained, matrix_app) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( tpca ), intent(inout) :: this real(kind=rk), intent(in), dimension(:,:) :: matrix integer, intent(in), optional :: npc character(len=*), intent(in), optional :: method real(kind=rk), intent(out), dimension(:,:), allocatable :: coeff real(kind=rk), intent(out), optional, dimension(:,:), allocatable :: score real(kind=rk), intent(out), optional, dimension(:), allocatable :: latent real(kind=rk), intent(out), optional, dimension(:), allocatable :: explained real(kind=rk), intent(out), optional, dimension(:,:), allocatable :: matrix_app procedure, public :: finalize => deallocate_tpca private pure elemental subroutine deallocate_tpca (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( tpca ), intent(inout) :: this Source Code type tpca integer :: ncol , nrow , npc character (:), allocatable :: method real ( rk ), dimension (:,:), allocatable :: matrix real ( rk ), dimension (:,:), allocatable :: coeff real ( rk ), dimension (:,:), allocatable :: score real ( rk ), dimension (:,:), allocatable :: matrix_app real ( rk ), dimension (:,:), allocatable :: mean_data real ( rk ), dimension (:), allocatable :: latent real ( rk ), dimension (:), allocatable :: explained_variance contains procedure :: initialize procedure :: compute_coeff procedure :: compute_score procedure :: reconstruct_data procedure :: cmp_explained_variance procedure :: pca procedure :: finalize => deallocate_tpca end type tpca","tags":"","loc":"type/tpca.html"},{"title":"initialize – ForPCA","text":"private pure subroutine initialize(this, matrix, npc, method) Type Bound tpca Arguments Type Intent Optional Attributes Name class( tpca ), intent(inout) :: this real(kind=rk), intent(in), dimension(:,:) :: matrix integer, intent(in), optional :: npc character(len=*), intent(in), optional :: method Called by proc~~initialize~~CalledByGraph proc~initialize forpca::tpca%initialize proc~pca forpca::tpca%pca proc~pca->proc~initialize program~benchmark benchmark program~benchmark->proc~pca program~test1 test1 program~test1->proc~pca Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine initialize ( this , matrix , npc , method ) class ( tpca ), intent ( inout ) :: this real ( rk ), dimension (:,:), intent ( in ) :: matrix integer , intent ( in ), optional :: npc character ( * ), intent ( in ), optional :: method #if defined(USE_COARRAY) if ( this_image () == 1 ) then #endif this % matrix = matrix this % nrow = size ( matrix , 1 ) this % ncol = size ( matrix , 2 ) if (. not . present ( npc )) then this % npc = this % ncol else this % npc = npc end if if (. not . present ( method )) then this % method = 'svd' else this % method = method end if #if defined(USE_COARRAY) end if #endif end subroutine initialize","tags":"","loc":"proc/initialize.html"},{"title":"compute_coeff – ForPCA","text":"private impure subroutine compute_coeff(this) Uses forsvd formatmul proc~~compute_coeff~~UsesGraph proc~compute_coeff forpca::tpca%compute_coeff formatmul formatmul proc~compute_coeff->formatmul forsvd forsvd proc~compute_coeff->forsvd Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound tpca Arguments Type Intent Optional Attributes Name class( tpca ), intent(inout) :: this Calls proc~~compute_coeff~~CallsGraph proc~compute_coeff forpca::tpca%compute_coeff eig eig proc~compute_coeff->eig mask mask proc~compute_coeff->mask order order proc~compute_coeff->order svd svd proc~compute_coeff->svd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compute_coeff~~CalledByGraph proc~compute_coeff forpca::tpca%compute_coeff proc~pca forpca::tpca%pca proc~pca->proc~compute_coeff program~benchmark benchmark program~benchmark->proc~pca program~test1 test1 program~test1->proc~pca Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine compute_coeff ( this ) use forsvd use formatmul , only : matmul class ( tpca ), intent ( inout ) :: this real ( rk ), dimension ( this % ncol ) :: mean real ( rk ), dimension ( this % ncol , this % ncol ) :: cov integer :: i #if defined(USE_COARRAY) if ( this_image () == 1 ) then #endif mean = sum ( this % matrix , dim = 1 ) / real ( this % nrow , kind = rk ) allocate ( this % mean_data ( this % nrow , this % ncol )) do i = 1 , this % nrow this % mean_data ( i , :) = this % matrix ( i , :) - mean end do #if defined(USE_COARRAY) end if #endif #if defined(USE_COARRAY) call co_broadcast ( this % mean_data , source_image = 1 ) sync all cov = matmul ( transpose ( this % mean_data ), this % mean_data , method = 'coarray' , option = 'm1' ) / real ( this % nrow - 1 , kind = rk ) #else cov = matmul ( transpose ( this % mean_data ), this % mean_data , method = 'default' , option = 'm1' ) / real ( this % nrow - 1 , kind = rk ) #endif #if defined(USE_COARRAY) if ( this_image () == 1 ) then #endif select case ( this % method ) case ( 'svd' ) block real ( rk ), dimension ( this % ncol , this % ncol ) :: U real ( rk ), dimension ( this % ncol , this % ncol ) :: VT real ( rk ), dimension ( this % ncol ) :: S call svd ( cov , U , S , VT ) this % latent = S ** 2 / ( this % ncol - 1 ) this % coeff = transpose ( VT ) end block case ( 'eig' ) block logical , dimension ( this % ncol ) :: mask integer , dimension ( this % ncol ) :: order call eig ( cov , this % coeff , this % latent ) ! Sort mask = . true . do i = lbound ( this % latent , 1 ), ubound ( this % latent , 1 ) order ( i ) = maxloc ( this % latent , 1 , mask ) mask ( order ( i )) = . false . end do this % latent = this % latent ( order ) this % coeff = this % coeff (:, order ) end block end select #if defined(USE_COARRAY) end if #endif end subroutine compute_coeff","tags":"","loc":"proc/compute_coeff.html"},{"title":"compute_score – ForPCA","text":"private pure subroutine compute_score(this) Type Bound tpca Arguments Type Intent Optional Attributes Name class( tpca ), intent(inout) :: this Called by proc~~compute_score~~CalledByGraph proc~compute_score forpca::tpca%compute_score proc~pca forpca::tpca%pca proc~pca->proc~compute_score program~benchmark benchmark program~benchmark->proc~pca program~test1 test1 program~test1->proc~pca Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine compute_score ( this ) class ( tpca ), intent ( inout ) :: this integer :: i , j #if defined(USE_COARRAY) if ( this_image () == 1 ) then #endif allocate ( this % score ( this % nrow , this % ncol )) do i = 1 , this % nrow do j = 1 , this % npc this % score ( i , j ) = dot_product ( this % mean_data ( i , :), this % coeff (:, j )) end do end do #if defined(USE_COARRAY) end if #endif end subroutine compute_score","tags":"","loc":"proc/compute_score.html"},{"title":"reconstruct_data – ForPCA","text":"private impure subroutine reconstruct_data(this) Uses formatmul proc~~reconstruct_data~~UsesGraph proc~reconstruct_data forpca::tpca%reconstruct_data formatmul formatmul proc~reconstruct_data->formatmul Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type Bound tpca Arguments Type Intent Optional Attributes Name class( tpca ), intent(inout) :: this Called by proc~~reconstruct_data~~CalledByGraph proc~reconstruct_data forpca::tpca%reconstruct_data proc~pca forpca::tpca%pca proc~pca->proc~reconstruct_data program~benchmark benchmark program~benchmark->proc~pca program~test1 test1 program~test1->proc~pca Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine reconstruct_data ( this ) use formatmul , only : matmul class ( tpca ), intent ( inout ) :: this real ( rk ), dimension (:, :), allocatable :: X_centered real ( rk ), dimension (:, :), allocatable :: pca_X integer :: i , j #if defined(USE_COARRAY) if ( this_image () == 1 ) then #endif X_centered = this % matrix - this % mean_data #if defined(USE_COARRAY) end if #endif #if defined(USE_COARRAY) call co_broadcast ( this % coeff , source_image = 1 ) call co_broadcast ( X_centered , source_image = 1 ) sync all this % matrix_app = matmul ( pca_X , transpose ( this % coeff ), method = 'coarray' , option = 'm1' ) + this % mean_data pca_X = matmul ( X_centered , this % coeff , method = 'coarray' , option = 'm1' ) #else this % matrix_app = matmul ( pca_X , transpose ( this % coeff )) + this % mean_data pca_X = matmul ( X_centered , this % coeff , method = 'default' , option = 'm1' ) #endif end subroutine reconstruct_data","tags":"","loc":"proc/reconstruct_data.html"},{"title":"cmp_explained_variance – ForPCA","text":"private pure subroutine cmp_explained_variance(this) Type Bound tpca Arguments Type Intent Optional Attributes Name class( tpca ), intent(inout) :: this Called by proc~~cmp_explained_variance~~CalledByGraph proc~cmp_explained_variance forpca::tpca%cmp_explained_variance proc~pca forpca::tpca%pca proc~pca->proc~cmp_explained_variance program~benchmark benchmark program~benchmark->proc~pca program~test1 test1 program~test1->proc~pca Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine cmp_explained_variance ( this ) class ( tpca ), intent ( inout ) :: this real ( rk ) :: sum_latent #if defined(USE_COARRAY) if ( this_image () == 1 ) then #endif sum_latent = sum ( this % latent ( 1 : this % npc )) this % explained_variance = this % latent / sum_latent #if defined(USE_COARRAY) end if #endif end subroutine cmp_explained_variance","tags":"","loc":"proc/cmp_explained_variance.html"},{"title":"pca – ForPCA","text":"private impure subroutine pca(this, matrix, npc, method, coeff, score, latent, explained, matrix_app) Type Bound tpca Arguments Type Intent Optional Attributes Name class( tpca ), intent(inout) :: this real(kind=rk), intent(in), dimension(:,:) :: matrix integer, intent(in), optional :: npc character(len=*), intent(in), optional :: method real(kind=rk), intent(out), dimension(:,:), allocatable :: coeff real(kind=rk), intent(out), optional, dimension(:,:), allocatable :: score real(kind=rk), intent(out), optional, dimension(:), allocatable :: latent real(kind=rk), intent(out), optional, dimension(:), allocatable :: explained real(kind=rk), intent(out), optional, dimension(:,:), allocatable :: matrix_app Calls proc~~pca~~CallsGraph proc~pca forpca::tpca%pca proc~cmp_explained_variance forpca::tpca%cmp_explained_variance proc~pca->proc~cmp_explained_variance proc~compute_coeff forpca::tpca%compute_coeff proc~pca->proc~compute_coeff proc~compute_score forpca::tpca%compute_score proc~pca->proc~compute_score proc~initialize forpca::tpca%initialize proc~pca->proc~initialize proc~reconstruct_data forpca::tpca%reconstruct_data proc~pca->proc~reconstruct_data eig eig proc~compute_coeff->eig mask mask proc~compute_coeff->mask order order proc~compute_coeff->order svd svd proc~compute_coeff->svd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pca~~CalledByGraph proc~pca forpca::tpca%pca program~benchmark benchmark program~benchmark->proc~pca program~test1 test1 program~test1->proc~pca Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine pca ( this , matrix , npc , method , coeff , score , latent , explained , matrix_app ) class ( tpca ), intent ( inout ) :: this real ( rk ), dimension (:,:), intent ( in ) :: matrix integer , intent ( in ), optional :: npc character ( * ), intent ( in ), optional :: method real ( rk ), dimension (:,:), allocatable , intent ( out ) :: coeff real ( rk ), dimension (:,:), allocatable , intent ( out ), optional :: score real ( rk ), dimension (:), allocatable , intent ( out ), optional :: latent real ( rk ), dimension (:), allocatable , intent ( out ), optional :: explained real ( rk ), dimension (:,:), allocatable , intent ( out ), optional :: matrix_app #if defined(USE_COARRAY) if ( this_image () == 1 ) then #endif call this % initialize ( matrix , npc , method ) #if defined(USE_COARRAY) end if #endif call this % compute_coeff () coeff = this % coeff #if defined(USE_COARRAY) if ( this_image () == 1 ) then #endif if ( present ( score )) then call this % compute_score () score = this % score end if if ( present ( latent )) then latent = this % latent end if if ( present ( explained )) then call this % cmp_explained_variance () explained = this % explained_variance * 10 0.0_rk end if #if defined(USE_COARRAY) end if #endif if ( present ( matrix_app )) then call this % reconstruct_data () matrix_app = this % matrix_app end if end subroutine pca","tags":"","loc":"proc/pca.html"},{"title":"deallocate_tpca – ForPCA","text":"private pure elemental subroutine deallocate_tpca(this) Type Bound tpca Arguments Type Intent Optional Attributes Name class( tpca ), intent(inout) :: this Called by proc~~deallocate_tpca~~CalledByGraph proc~deallocate_tpca forpca::tpca%deallocate_tpca program~benchmark benchmark program~benchmark->proc~deallocate_tpca program~test1 test1 program~test1->proc~deallocate_tpca Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine deallocate_tpca ( this ) class ( tpca ), intent ( inout ) :: this ! if (this_image() == 1) then if ( allocated ( this % matrix )) deallocate ( this % matrix ) if ( allocated ( this % coeff )) deallocate ( this % coeff ) if ( allocated ( this % mean_data )) deallocate ( this % mean_data ) if ( allocated ( this % score )) deallocate ( this % score ) if ( allocated ( this % matrix_app )) deallocate ( this % matrix_app ) ! end if end subroutine deallocate_tpca","tags":"","loc":"proc/deallocate_tpca.html"},{"title":"forpca – ForPCA","text":"Uses foreig kinds module~~forpca~~UsesGraph module~forpca forpca foreig foreig module~forpca->foreig kinds kinds module~forpca->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forpca~~UsedByGraph module~forpca forpca program~benchmark benchmark program~benchmark->module~forpca program~test1 test1 program~test1->module~forpca Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: tpca Components Type Visibility Attributes Name Initial integer, public :: ncol integer, public :: nrow integer, public :: npc character(len=:), public, allocatable :: method real(kind=rk), public, dimension(:,:), allocatable :: matrix real(kind=rk), public, dimension(:,:), allocatable :: coeff real(kind=rk), public, dimension(:,:), allocatable :: score real(kind=rk), public, dimension(:,:), allocatable :: matrix_app real(kind=rk), public, dimension(:,:), allocatable :: mean_data real(kind=rk), public, dimension(:), allocatable :: latent real(kind=rk), public, dimension(:), allocatable :: explained_variance Type-Bound Procedures procedure, public :: initialize procedure, public :: compute_coeff procedure, public :: compute_score procedure, public :: reconstruct_data procedure, public :: cmp_explained_variance procedure, public :: pca procedure, public :: finalize => deallocate_tpca Subroutines private pure subroutine initialize (this, matrix, npc, method) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( tpca ), intent(inout) :: this real(kind=rk), intent(in), dimension(:,:) :: matrix integer, intent(in), optional :: npc character(len=*), intent(in), optional :: method private impure subroutine compute_coeff (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( tpca ), intent(inout) :: this private pure subroutine compute_score (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( tpca ), intent(inout) :: this private impure subroutine reconstruct_data (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( tpca ), intent(inout) :: this private pure subroutine cmp_explained_variance (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( tpca ), intent(inout) :: this private impure subroutine pca (this, matrix, npc, method, coeff, score, latent, explained, matrix_app) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( tpca ), intent(inout) :: this real(kind=rk), intent(in), dimension(:,:) :: matrix integer, intent(in), optional :: npc character(len=*), intent(in), optional :: method real(kind=rk), intent(out), dimension(:,:), allocatable :: coeff real(kind=rk), intent(out), optional, dimension(:,:), allocatable :: score real(kind=rk), intent(out), optional, dimension(:), allocatable :: latent real(kind=rk), intent(out), optional, dimension(:), allocatable :: explained real(kind=rk), intent(out), optional, dimension(:,:), allocatable :: matrix_app private pure elemental subroutine deallocate_tpca (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( tpca ), intent(inout) :: this","tags":"","loc":"module/forpca.html"},{"title":"test1 – ForPCA","text":"Uses forpca kinds program~~test1~~UsesGraph program~test1 test1 kinds kinds program~test1->kinds module~forpca forpca program~test1->module~forpca module~forpca->kinds foreig foreig module~forpca->foreig Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test1~~CallsGraph program~test1 test1 proc~deallocate_tpca forpca::tpca%deallocate_tpca program~test1->proc~deallocate_tpca proc~pca forpca::tpca%pca program~test1->proc~pca proc~cmp_explained_variance forpca::tpca%cmp_explained_variance proc~pca->proc~cmp_explained_variance proc~compute_coeff forpca::tpca%compute_coeff proc~pca->proc~compute_coeff proc~compute_score forpca::tpca%compute_score proc~pca->proc~compute_score proc~initialize forpca::tpca%initialize proc~pca->proc~initialize proc~reconstruct_data forpca::tpca%reconstruct_data proc~pca->proc~reconstruct_data eig eig proc~compute_coeff->eig mask mask proc~compute_coeff->mask order order proc~compute_coeff->order svd svd proc~compute_coeff->svd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), dimension(:,:), allocatable :: matrix real(kind=rk), dimension(:,:), allocatable :: matrix_app real(kind=rk), dimension(:,:), allocatable :: coeff real(kind=rk), dimension(:,:), allocatable :: score real(kind=rk), dimension(:), allocatable :: latent real(kind=rk), dimension(:), allocatable :: explained type( tpca ) :: p Source Code program test1 use kinds use forpca , only : tpca implicit none real ( rk ), dimension (:,:), allocatable :: matrix real ( rk ), dimension (:,:), allocatable :: matrix_app real ( rk ), dimension (:,:), allocatable :: coeff real ( rk ), dimension (:,:), allocatable :: score real ( rk ), dimension (:), allocatable :: latent real ( rk ), dimension (:), allocatable :: explained type ( tpca ) :: p allocate ( matrix ( 5 , 2 )) matrix ( 1 , 1 ) = 0.123_rk matrix ( 1 , 2 ) = 0.456_rk matrix ( 2 , 1 ) = 0.789_rk matrix ( 2 , 2 ) = 0.234_rk matrix ( 3 , 1 ) = 0.567_rk matrix ( 3 , 2 ) = 0.890_rk matrix ( 4 , 1 ) = 0.123_rk matrix ( 4 , 2 ) = 0.678_rk matrix ( 5 , 1 ) = 0.901_rk matrix ( 5 , 2 ) = 0.345_rk call p % pca ( matrix , 2 , 'svd' , coeff , score , latent , explained , matrix_app ) #if defined(USE_COARRAY) if ( this_image () == 1 ) then print * , p % matrix_app ( 1 , 1 ) print * , p % matrix_app ( 1 , 2 ) print * , p % matrix_app ( 2 , 1 ) print * , p % matrix_app ( 2 , 2 ) print * , p % matrix_app ( 3 , 1 ) print * , p % matrix_app ( 3 , 2 ) print * , p % matrix_app ( 4 , 1 ) print * , p % matrix_app ( 4 , 2 ) print * , p % matrix_app ( 5 , 1 ) print * , p % matrix_app ( 5 , 2 ) end if #else print * , p % matrix_app ( 1 , 1 ) print * , p % matrix_app ( 1 , 2 ) print * , p % matrix_app ( 2 , 1 ) print * , p % matrix_app ( 2 , 2 ) print * , p % matrix_app ( 3 , 1 ) print * , p % matrix_app ( 3 , 2 ) print * , p % matrix_app ( 4 , 1 ) print * , p % matrix_app ( 4 , 2 ) print * , p % matrix_app ( 5 , 1 ) print * , p % matrix_app ( 5 , 2 ) #endif call p % finalize () end program test1","tags":"","loc":"program/test1.html"},{"title":"benchmark – ForPCA","text":"Uses forpca fortime kinds program~~benchmark~~UsesGraph program~benchmark benchmark fortime fortime program~benchmark->fortime kinds kinds program~benchmark->kinds module~forpca forpca program~benchmark->module~forpca module~forpca->kinds foreig foreig module~forpca->foreig Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~benchmark~~CallsGraph program~benchmark benchmark proc~deallocate_tpca forpca::tpca%deallocate_tpca program~benchmark->proc~deallocate_tpca proc~pca forpca::tpca%pca program~benchmark->proc~pca timer_start timer_start program~benchmark->timer_start timer_stop timer_stop program~benchmark->timer_stop proc~cmp_explained_variance forpca::tpca%cmp_explained_variance proc~pca->proc~cmp_explained_variance proc~compute_coeff forpca::tpca%compute_coeff proc~pca->proc~compute_coeff proc~compute_score forpca::tpca%compute_score proc~pca->proc~compute_score proc~initialize forpca::tpca%initialize proc~pca->proc~initialize proc~reconstruct_data forpca::tpca%reconstruct_data proc~pca->proc~reconstruct_data eig eig proc~compute_coeff->eig mask mask proc~compute_coeff->mask order order proc~compute_coeff->order svd svd proc~compute_coeff->svd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), dimension(:,:), allocatable :: matrix real(kind=rk), dimension(:,:), allocatable :: matrix_app real(kind=rk), dimension(:,:), allocatable :: coeff real(kind=rk), dimension(:,:), allocatable :: score real(kind=rk), dimension(:), allocatable :: latent real(kind=rk), dimension(:), allocatable :: explained type( tpca ) :: p type(timer) :: t Source Code program benchmark use kinds use forpca , only : tpca use fortime , only : timer implicit none real ( rk ), dimension (:,:), allocatable :: matrix real ( rk ), dimension (:,:), allocatable :: matrix_app real ( rk ), dimension (:,:), allocatable :: coeff real ( rk ), dimension (:,:), allocatable :: score real ( rk ), dimension (:), allocatable :: latent real ( rk ), dimension (:), allocatable :: explained type ( tpca ) :: p type ( timer ) :: t allocate ( matrix ( 100 , 100 )) #if defined(USE_COARRAY) sync all call t % timer_start () call p % pca ( matrix , 50 , 'svd' , coeff , score , latent , explained , matrix_app ) call t % timer_stop ( message = ' Elapsed time (benchmark: pca, coarray):' ) sync all call p % finalize () #else call t % timer_start () call p % pca ( matrix , 50 , 'svd' , coeff , score , latent , explained , matrix_app ) call t % timer_stop ( message = ' Elapsed time (benchmark: pca):' ) #endif end program benchmark","tags":"","loc":"program/benchmark.html"},{"title":"forpca.f90 – ForPCA","text":"Files dependent on this one sourcefile~~forpca.f90~~AfferentGraph sourcefile~forpca.f90 forpca.f90 sourcefile~benchmark.f90 benchmark.f90 sourcefile~benchmark.f90->sourcefile~forpca.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~forpca.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forpca use kinds use foreig implicit none private public tpca !=============================================================================== !> author: Seyed Ali Ghasemi type tpca integer :: ncol , nrow , npc character (:), allocatable :: method real ( rk ), dimension (:,:), allocatable :: matrix real ( rk ), dimension (:,:), allocatable :: coeff real ( rk ), dimension (:,:), allocatable :: score real ( rk ), dimension (:,:), allocatable :: matrix_app real ( rk ), dimension (:,:), allocatable :: mean_data real ( rk ), dimension (:), allocatable :: latent real ( rk ), dimension (:), allocatable :: explained_variance contains procedure :: initialize procedure :: compute_coeff procedure :: compute_score procedure :: reconstruct_data procedure :: cmp_explained_variance procedure :: pca procedure :: finalize => deallocate_tpca end type tpca !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine initialize ( this , matrix , npc , method ) class ( tpca ), intent ( inout ) :: this real ( rk ), dimension (:,:), intent ( in ) :: matrix integer , intent ( in ), optional :: npc character ( * ), intent ( in ), optional :: method #if defined(USE_COARRAY) if ( this_image () == 1 ) then #endif this % matrix = matrix this % nrow = size ( matrix , 1 ) this % ncol = size ( matrix , 2 ) if (. not . present ( npc )) then this % npc = this % ncol else this % npc = npc end if if (. not . present ( method )) then this % method = 'svd' else this % method = method end if #if defined(USE_COARRAY) end if #endif end subroutine initialize !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine compute_coeff ( this ) use forsvd use formatmul , only : matmul class ( tpca ), intent ( inout ) :: this real ( rk ), dimension ( this % ncol ) :: mean real ( rk ), dimension ( this % ncol , this % ncol ) :: cov integer :: i #if defined(USE_COARRAY) if ( this_image () == 1 ) then #endif mean = sum ( this % matrix , dim = 1 ) / real ( this % nrow , kind = rk ) allocate ( this % mean_data ( this % nrow , this % ncol )) do i = 1 , this % nrow this % mean_data ( i , :) = this % matrix ( i , :) - mean end do #if defined(USE_COARRAY) end if #endif #if defined(USE_COARRAY) call co_broadcast ( this % mean_data , source_image = 1 ) sync all cov = matmul ( transpose ( this % mean_data ), this % mean_data , method = 'coarray' , option = 'm1' ) / real ( this % nrow - 1 , kind = rk ) #else cov = matmul ( transpose ( this % mean_data ), this % mean_data , method = 'default' , option = 'm1' ) / real ( this % nrow - 1 , kind = rk ) #endif #if defined(USE_COARRAY) if ( this_image () == 1 ) then #endif select case ( this % method ) case ( 'svd' ) block real ( rk ), dimension ( this % ncol , this % ncol ) :: U real ( rk ), dimension ( this % ncol , this % ncol ) :: VT real ( rk ), dimension ( this % ncol ) :: S call svd ( cov , U , S , VT ) this % latent = S ** 2 / ( this % ncol - 1 ) this % coeff = transpose ( VT ) end block case ( 'eig' ) block logical , dimension ( this % ncol ) :: mask integer , dimension ( this % ncol ) :: order call eig ( cov , this % coeff , this % latent ) ! Sort mask = . true . do i = lbound ( this % latent , 1 ), ubound ( this % latent , 1 ) order ( i ) = maxloc ( this % latent , 1 , mask ) mask ( order ( i )) = . false . end do this % latent = this % latent ( order ) this % coeff = this % coeff (:, order ) end block end select #if defined(USE_COARRAY) end if #endif end subroutine compute_coeff !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine compute_score ( this ) class ( tpca ), intent ( inout ) :: this integer :: i , j #if defined(USE_COARRAY) if ( this_image () == 1 ) then #endif allocate ( this % score ( this % nrow , this % ncol )) do i = 1 , this % nrow do j = 1 , this % npc this % score ( i , j ) = dot_product ( this % mean_data ( i , :), this % coeff (:, j )) end do end do #if defined(USE_COARRAY) end if #endif end subroutine compute_score !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine reconstruct_data ( this ) use formatmul , only : matmul class ( tpca ), intent ( inout ) :: this real ( rk ), dimension (:, :), allocatable :: X_centered real ( rk ), dimension (:, :), allocatable :: pca_X integer :: i , j #if defined(USE_COARRAY) if ( this_image () == 1 ) then #endif X_centered = this % matrix - this % mean_data #if defined(USE_COARRAY) end if #endif #if defined(USE_COARRAY) call co_broadcast ( this % coeff , source_image = 1 ) call co_broadcast ( X_centered , source_image = 1 ) sync all this % matrix_app = matmul ( pca_X , transpose ( this % coeff ), method = 'coarray' , option = 'm1' ) + this % mean_data pca_X = matmul ( X_centered , this % coeff , method = 'coarray' , option = 'm1' ) #else this % matrix_app = matmul ( pca_X , transpose ( this % coeff )) + this % mean_data pca_X = matmul ( X_centered , this % coeff , method = 'default' , option = 'm1' ) #endif end subroutine reconstruct_data !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine cmp_explained_variance ( this ) class ( tpca ), intent ( inout ) :: this real ( rk ) :: sum_latent #if defined(USE_COARRAY) if ( this_image () == 1 ) then #endif sum_latent = sum ( this % latent ( 1 : this % npc )) this % explained_variance = this % latent / sum_latent #if defined(USE_COARRAY) end if #endif end subroutine cmp_explained_variance !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine pca ( this , matrix , npc , method , coeff , score , latent , explained , matrix_app ) class ( tpca ), intent ( inout ) :: this real ( rk ), dimension (:,:), intent ( in ) :: matrix integer , intent ( in ), optional :: npc character ( * ), intent ( in ), optional :: method real ( rk ), dimension (:,:), allocatable , intent ( out ) :: coeff real ( rk ), dimension (:,:), allocatable , intent ( out ), optional :: score real ( rk ), dimension (:), allocatable , intent ( out ), optional :: latent real ( rk ), dimension (:), allocatable , intent ( out ), optional :: explained real ( rk ), dimension (:,:), allocatable , intent ( out ), optional :: matrix_app #if defined(USE_COARRAY) if ( this_image () == 1 ) then #endif call this % initialize ( matrix , npc , method ) #if defined(USE_COARRAY) end if #endif call this % compute_coeff () coeff = this % coeff #if defined(USE_COARRAY) if ( this_image () == 1 ) then #endif if ( present ( score )) then call this % compute_score () score = this % score end if if ( present ( latent )) then latent = this % latent end if if ( present ( explained )) then call this % cmp_explained_variance () explained = this % explained_variance * 10 0.0_rk end if #if defined(USE_COARRAY) end if #endif if ( present ( matrix_app )) then call this % reconstruct_data () matrix_app = this % matrix_app end if end subroutine pca !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine deallocate_tpca ( this ) class ( tpca ), intent ( inout ) :: this ! if (this_image() == 1) then if ( allocated ( this % matrix )) deallocate ( this % matrix ) if ( allocated ( this % coeff )) deallocate ( this % coeff ) if ( allocated ( this % mean_data )) deallocate ( this % mean_data ) if ( allocated ( this % score )) deallocate ( this % score ) if ( allocated ( this % matrix_app )) deallocate ( this % matrix_app ) ! end if end subroutine deallocate_tpca !=============================================================================== end module forpca","tags":"","loc":"sourcefile/forpca.f90.html"},{"title":"test1.f90 – ForPCA","text":"This file depends on sourcefile~~test1.f90~~EfferentGraph sourcefile~test1.f90 test1.f90 sourcefile~forpca.f90 forpca.f90 sourcefile~test1.f90->sourcefile~forpca.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test1 use kinds use forpca , only : tpca implicit none real ( rk ), dimension (:,:), allocatable :: matrix real ( rk ), dimension (:,:), allocatable :: matrix_app real ( rk ), dimension (:,:), allocatable :: coeff real ( rk ), dimension (:,:), allocatable :: score real ( rk ), dimension (:), allocatable :: latent real ( rk ), dimension (:), allocatable :: explained type ( tpca ) :: p allocate ( matrix ( 5 , 2 )) matrix ( 1 , 1 ) = 0.123_rk matrix ( 1 , 2 ) = 0.456_rk matrix ( 2 , 1 ) = 0.789_rk matrix ( 2 , 2 ) = 0.234_rk matrix ( 3 , 1 ) = 0.567_rk matrix ( 3 , 2 ) = 0.890_rk matrix ( 4 , 1 ) = 0.123_rk matrix ( 4 , 2 ) = 0.678_rk matrix ( 5 , 1 ) = 0.901_rk matrix ( 5 , 2 ) = 0.345_rk call p % pca ( matrix , 2 , 'svd' , coeff , score , latent , explained , matrix_app ) #if defined(USE_COARRAY) if ( this_image () == 1 ) then print * , p % matrix_app ( 1 , 1 ) print * , p % matrix_app ( 1 , 2 ) print * , p % matrix_app ( 2 , 1 ) print * , p % matrix_app ( 2 , 2 ) print * , p % matrix_app ( 3 , 1 ) print * , p % matrix_app ( 3 , 2 ) print * , p % matrix_app ( 4 , 1 ) print * , p % matrix_app ( 4 , 2 ) print * , p % matrix_app ( 5 , 1 ) print * , p % matrix_app ( 5 , 2 ) end if #else print * , p % matrix_app ( 1 , 1 ) print * , p % matrix_app ( 1 , 2 ) print * , p % matrix_app ( 2 , 1 ) print * , p % matrix_app ( 2 , 2 ) print * , p % matrix_app ( 3 , 1 ) print * , p % matrix_app ( 3 , 2 ) print * , p % matrix_app ( 4 , 1 ) print * , p % matrix_app ( 4 , 2 ) print * , p % matrix_app ( 5 , 1 ) print * , p % matrix_app ( 5 , 2 ) #endif call p % finalize () end program test1","tags":"","loc":"sourcefile/test1.f90.html"},{"title":"benchmark.f90 – ForPCA","text":"This file depends on sourcefile~~benchmark.f90~~EfferentGraph sourcefile~benchmark.f90 benchmark.f90 sourcefile~forpca.f90 forpca.f90 sourcefile~benchmark.f90->sourcefile~forpca.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program benchmark use kinds use forpca , only : tpca use fortime , only : timer implicit none real ( rk ), dimension (:,:), allocatable :: matrix real ( rk ), dimension (:,:), allocatable :: matrix_app real ( rk ), dimension (:,:), allocatable :: coeff real ( rk ), dimension (:,:), allocatable :: score real ( rk ), dimension (:), allocatable :: latent real ( rk ), dimension (:), allocatable :: explained type ( tpca ) :: p type ( timer ) :: t allocate ( matrix ( 100 , 100 )) #if defined(USE_COARRAY) sync all call t % timer_start () call p % pca ( matrix , 50 , 'svd' , coeff , score , latent , explained , matrix_app ) call t % timer_stop ( message = ' Elapsed time (benchmark: pca, coarray):' ) sync all call p % finalize () #else call t % timer_start () call p % pca ( matrix , 50 , 'svd' , coeff , score , latent , explained , matrix_app ) call t % timer_stop ( message = ' Elapsed time (benchmark: pca):' ) #endif end program benchmark","tags":"","loc":"sourcefile/benchmark.f90.html"}]}